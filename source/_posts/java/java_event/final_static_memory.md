---
layout: post
title: Java内存机制及final、static总结
date: 2014-11-19
category: java
tags: java
toc: true
---
本文整理自[Java中的内存处理机制和final、static、final static总结](Java中的内存处理机制和final、static、final static总结)和[Java关键字final、static使用总结](Java关键字final、static使用总结),作为自己学习的基础。<!--more-->
## java内存机制
java程序运行在JVM上，JVM实现了java的平台无关性，所以在学习java内存分配原理的时候一定要牢记这一切都是在JVM中进行的，JVM是内存分配原理的基础与前提。
### 一个完整的Java程序运行过程会涉及一下内存区域:
**寄存器**: JVM内部虚拟寄存器，存取速度非常快，程序不可控制。
**栈**: 保存局部变量的值，包括：
    * 用来保存基本数据类型的值
    * 保存类的实例, 即堆区堆对象的引用(指针)
    * 也可用来保存加载方法时的帧
**堆**: 用来存放动态产生的数据，比如`new`出来的**对象**。注意创建出来的对象只包含只属于各自的成员变量，并不包括成员方法。因此同一个类的对象拥有各自的成员变量，存储在各自的堆中，但他们共享该类的方法，并不是每创建一个对象就把成员方法复制一次。
**常量池**: JVM为每个已加载的类型维护一个常量池，常量池就是这个类型用到的常量的一个有序集合。包括直接常量(基本类型，String)和对其他(类型、方法、字段)的**符号引用**。池中的数据和数组一样通过索引访问。由于常量池包含了一个类型所有的对其他类型、方法、字段的符号引用，所以常量池在Java的动态链接中起了核心作用。**常量池存在于堆中**
**代码段**: 用来存放从硬盘上读取的源程序代码。
**全局数据段**: 用来存放`static`定义的静态成员或全局变量。分配该区时内存全部清零，结果变量的初始化为0。
![内存分配图]({{BASE_PATH}}/image/java/java_event/imag1.jpg)
### 对于java和内存之间，有如下几点需要注意:
1. 一个java文件，只要有`main`入口方法，我们就认为这是一个java程序，可以单独编译运行
2. 无论是普通类型的变量还是引用类型的变量(俗称实例)，都可以作为局部变量，他们都可以出现在栈中。只不过普通类型的变量在栈中直接保存它所对应的值，而应用类型的变量保存的是一个指向堆区的指针，通过这个指针，就可以找到这个实例在堆区对应的对象。因此，普通类型变量只在栈区占用一块内存，而引用类型变量要在栈区栈和栈堆区各占一块内存。
3. 分清什么是实例什么是对象。`Class a = new Class();`此时a叫实例，而不能说a是对象。实例在栈中，对象在堆中，操作实例实际上是通过实例的指针间接操作对象。多个实例可以指向同一个对象。
4. 栈中的数据和堆中的数据销毁并不同步。方法一旦结束，栈中的局部变量立即销毁，但是堆中的对象不一定销毁。因为可能有其他变量也指向了这个对象，直到栈中没有变量指针指向堆中的对象时，它才销毁，而且还不是马上销毁，等垃圾回收扫描时才可以被销毁。
5. 以上的栈、堆、代码段等等都是相对于应用程序而言的。每个应用程序都对应唯一的一个JVM实例，每一个JVM实例都有自己的内存区域，互不影响。并且这些内存区域是所有线程共享的。这里提到的栈和堆都是整体上的概念，这些堆栈还可以细分。
6. 类的成员变量在不同对象中各不相同，都有自己的存储空间(成员变量在堆中的对象中)。而类的方法却是该类的所有对象共享的，只有一套，对象使用的时候方法才被压入栈，方法不使用则不占用内存。
## Java关键字`final`、`static`使用说明
### final
根据程序上下文环境，Java关键字`final`有**这是无法改变的**或者**终态**的含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：**设计或效率**
`final类`不能被继承，没有子类，`final`类中的方法默认是`final`的
`final方法`不能被子类的方法覆盖，但可以继承
`final成员变量`表示常量，只能被赋值一次，赋值后不再改变
`final`不能用于修饰构造方法
注意：父类的`private`成员方法是不能被子类方法覆盖的，因此`private`类型的方法默认是`final`类型的。
### static
static表示**全局**或者**静态**的意思，用来修饰成员变量和成员方法，也可以形成静态`static`代码块，但Java语言中没有全局变量概念，但是Java语言中没有全局变量的概念。
`被static修饰的成员变量和成员方法独立于该类的任何对象`。也就是说，它不依赖特定的实例，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区域的方法区内找到它们。因此，`static`对象可以在它的任何对象创建之前访问，无需任何对象。

**用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它类的对象时，不生成static变量的副本，而是类的所有实例共享一个static变量**

`static变量前可以有private修饰，表示这个变量可以在类的静态代码块中，或者类的其他静态成员方法中使用(当然也可以在非静态成员方法中使用)，但是不能在其他类中通过类名来直接引用，这点很重要。`实际上，你需要明白,`private`是访问权限限定，`static`表示不要实例化就可以使用。

用`static`修饰的代码块表示静态代码块，当Java虚拟机(JVM)加载类时，就会执行该代码块。
### static和final一块表示
`static final`用来修饰成员变量和成员方法，可以简单理解为**全局常量**
对于变量，表示一旦给值就不可修改，并且通过类名可以访问。
对于方法，表示不可覆盖，并且可以通过类名直接访问。

特别需要注意一个问题:
对于被`static`和`final`修饰过的实例常量，实例本身不能再改变了，但对于一些容器类型(比如，ArrayList、HashMap)的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象。

